// vim: ai:sts=3:sw=3:filetype=javascript

import Debug   from 'debug'
const  debug = Debug('giraphe:walk')
import assert  from 'power-assert'

import _       from 'lodash'


// Okay, yes, before you flip your hat, this is a JavaScript file compiled through Mustache
// templates. Yes, I already know I'm a bad person and should feel bad. Can we move past that?
//
// The constructor that invokes this through `eval()` passes in some useful contextual modules,
// which we consume and close-over immediately. The actual meat is implemented in the
// function-object that we immediately return to `constructWalkFunction`.
//
// Various bits and pieces of `walk()` are completely omitted from the final function, based on
// analysis of the sorts of arguments it will be dealing with, preformed in the `Walker()`
// constructor.
//
// (Of note, there's also some nasty backflips to satisfy Babel; this entire file has to *transpile*
// as if it were, vaguely, a single block of source-code ... even though, at runtime, a completely
// *different* block of source-code, consisting of this file with chunks removed, is actually
// compiled. For instance, `const` is basically a no-no; and I can't excise parts of statements,
// unless the statements compile both with and without that part.)
export default function(symbols, $){                               debug( 'walk() constructed:', $ )

return function walk(current, parent, cachebacks, runbacks, allbacks, visited = new Object){
                                                                         debug( 'walk():', current )
                                                                           assert( null != current )
                                                                     assert( 0 !== allbacks.length )

   let key_current;
   /* {{#keyer?}} */ key_current = $.keyer.call(current, current) /* {{/keyer?}} */
   /* {{^keyer?}} */ key_current = current[$.key]                 /* {{/keyer?}} */
                                     assert( typeof key_current === 'string' && key_current !== '' )

   if (visited[key_current]) return null
       visited[key_current] = current

   let aborted = false

   const discovered = new Object
       , rejected = ! _.every(runbacks, cb => {
      const rv = cb.call(current, current, parent, discovered, visited, allbacks)

      // If it returns a boolean, or nothing at all, then it's a ‘filter-back’,
           if (rv === false)              return false
      else if (null == rv || rv === true) return true

      // and ‘abort-backs’ are a special case,
      else if (rv === symbols.abortIteration) {
         aborted = yes
         return false                                                                              }

      // else, it's a ‘supply-back’!

      // FIXME: D.R.Y. this ffs
      /* {{#predicate?}} */
      else if ($.predicate.call(rv, rv)) {
         let rv_key;
         /* {{#keyer?}} */ rv_key = $.keyer.call(rv, rv) /* {{/keyer?}} */
         /* {{^keyer?}} */ rv_key = rv[$.key]            /* {{/keyer?}} */
         discovered[rv_key] = rv
      }
      /* {{/predicate?}} {{^predicate?}} */
      else if (rv instanceof $.class) {
         let rv_key;
         /* {{#keyer?}} */ rv_key = $.keyer.call(rv, rv) /* {{/keyer?}} */
         /* {{^keyer?}} */ rv_key = rv[$.key]            /* {{/keyer?}} */
         discovered[rv_key] = rv
      }
      /* {{/predicate?}} */


      if (_.isArray(rv)) {
         /* {{#predicate?}} */
         assert( _.every(rv, element => $.predicate.call(element, element)) )
         /* {{/predicate?}} {{^predicate?}} */
         assert( _.every(rv, element => element instanceof $.class) )
         /* {{/predicate?}} */

         const rvs = _.reduce(rv, (rvs, ele) => {
            let key_ele;
            /* {{#keyer?}} */ key_ele = $.keyer.call(ele, ele) /* {{/keyer?}} */
            /* {{^keyer?}} */ key_ele = ele[$.key]             /* {{/keyer?}} */

            acc[key_ele] = v

            return acc
         }, new Object)
         _.assign(discovered, rvs)                                                                 }


      else {
         /* {{#predicate?}} */
         assert( _.every(rv, ele => $.predicate.call(ele, ele)) )
         /* {{/predicate?}} {{^predicate?}} */
         assert( _.every(rv, ele => ele instanceof $.class) )
         /* {{/predicate?}} */

         _.assign(discovered, rv)                                                                  }

      return rv                                                                                   })

      if (aborted)  return false // If walk() returns `false`, it immediately propagates upwards,
      if (rejected) return {}    // but if it was rejected, then merely add nothing on this step


      let can_cache = true

      for (key_ele in discovered) {
         const ele    = discovered[key_ele]
             , result = walk(ele, current, cachebacks, runbacks, allbacks, visited)

         if (false === result) return false

         if (null == result) can_cache = null // invalidate the cache if *any* child was skipped
         _.assign(discovered, result)
      }

      discovered[key_current] = current
      return discovered                                                                          } }
